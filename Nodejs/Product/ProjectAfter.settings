<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Choose>
    <When Condition="'$(Language)' == 'C#' and !$(SuppressCommonAssemblyMetadata)">
      <PropertyGroup>
        <TrackFileAccess>false</TrackFileAccess>            <!-- CHECK RELEVANCE -->
      </PropertyGroup>
      <ItemGroup>
        <Compile Include="$(BuildRoot)\Nodejs\Product\AssemblyInfoCommon.cs">
          <Link>AssemblyInfoCommon.cs</Link>
        </Compile>
        <Compile Include="$(BuildRoot)\Nodejs\Product\AssemblyVersion.cs">
          <Link>AssemblyVersion.cs</Link>
        </Compile>
      </ItemGroup>
      <PropertyGroup>
        <TrackFileAccess>true</TrackFileAccess>             <!-- CHECK RELEVANCE -->
      </PropertyGroup>
    </When>
  </Choose>
  <Import Project="$(BuildRoot)\Build\Common.Build.targets" />
    <!--
    =================================================================================
      Transforms our ConditionalEmbeddedResource into EmbeddedResource item groups by
      doing a search/replace in the .resx file and writing out a new file.
      
      Currently the search and replace just updates the VS target version
    =================================================================================
    -->

  <Target Name="ConditionalResx"
          BeforeTargets="MainResourcesGeneration"
          Condition="'@(ConditionalEmbeddedResource)' != ''"
          >
    
          
    <WriteLinesToFile 
      File="@(ConditionalEmbeddedResource->'%(RootDir)%(Directory)%(Filename).xform.resx')" 
      Lines="$([System.IO.File]::ReadAllText('%(fullpath)').Replace(&quot;_VSVERSION_&quot;,&quot;$(VSTarget)&quot;))" 
      Overwrite="true"/> 
      
    <ItemGroup>
      <EmbeddedResource Include="@(ConditionalEmbeddedResource->'%(RootDir)%(Directory)%(Filename).xform.resx')">
        <ManifestResourceName>%(ConditionalEmbeddedResource.ManifestResourceName)</ManifestResourceName>
        <MergeWithCTO Condition="'%(ConditionalEmbeddedResource.MergeWithCTO)' != ''">%(ConditionalEmbeddedResource.MergeWithCTO)</MergeWithCTO>
        <LastGenOutput Condition="'%(ConditionalEmbeddedResource.LastGenOutput)' != ''">%(ConditionalEmbeddedResource.LastGenOutput)</LastGenOutput>
        <Generator Condition="'%(ConditionalEmbeddedResource.Generator)' != ''">%(ConditionalEmbeddedResource.Generator)</Generator>
      </EmbeddedResource>
    </ItemGroup>
  </Target>

  <Target Name="TransformZipProject"
          BeforeTargets="MainResourcesGeneration"
          Condition="'@(TransformedZipProject)' != ''"
          >
    <WriteLinesToFile 
      File="@(TransformedZipProject->'%(RootDir)%(Directory)%(Filename)')" 
      Lines="$([System.IO.File]::ReadAllText('%(fullpath)').Replace(&quot;_VSVERSION_&quot;,&quot;$(VSTarget)&quot;))" 
      Overwrite="true"/> 
      
    <ItemGroup>
      <ZipProject Include="@(TransformedZipProject->'%(RootDir)%(Directory)%(Filename)')" />
    </ItemGroup>
  </Target>
  <Target Name="TransformMultiProjectZipProject" BeforeTargets="MainResourcesGeneration" Inputs="@(MultiProjectZipProject)" Outputs="@(_ZipProject.ZipFile)">
    <!-- Supports ziping up a new project template which contains multiple projects.  The project template needs to contain
         a project.root file which indicates the root of the project file.  It can then have a directory hierarchy (needed for
         multiple vstemplate files) below the project which ZipProject doesn't support -->
    <ItemGroup>
      <_ZipProject Include="@(MultiProjectZipProject)" Condition="'@(MultiProjectZipProject)' != ''">
        <ZipFile>$(ZipIntermediatePath)$([System.IO.Path]::GetFileName($([MSBuild]::GetDirectoryNameOfFileAbove('%(MultiProjectZipProject.FullPath)', project.root)))).zip</ZipFile>
        <RootPath>$([MSBuild]::MakeRelative($(MSBuildProjectDirectory), $([MSBuild]::GetDirectoryNameOfFileAbove('%(MultiProjectZipProject.FullPath)', project.root))))</RootPath>
      </_ZipProject>
    </ItemGroup>
  </Target>
</Project>

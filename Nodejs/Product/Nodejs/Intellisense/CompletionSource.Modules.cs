/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation. 
 *
 * This source code is subject to terms and conditions of the Apache License, Version 2.0. A 
 * copy of the license can be found in the License.html file at the root of this distribution. If 
 * you cannot locate the Apache License, Version 2.0, please send an email to 
 * vspython@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
 * by the terms of the Apache License, Version 2.0.
 *
 * You must not remove this notice, or any other, from this software.
 *
 * ***************************************************************************/

using System.Collections.Generic;
using Microsoft.VisualStudio.Language.Intellisense;

namespace Microsoft.NodejsTools.Intellisense {
    sealed partial class CompletionSource : ICompletionSource {
        private static Dictionary<string, string> _nodejsModules = new Dictionary<string, string>() {
            {"timers", "All of the timer functions are globals.  You do not need to require()\r\nthis module in order to use them." },
            {"module", "Node has a simple module loading system.  In Node, files and modules are in\r\none-to-one correspondence.  As an example, foo.js loads the module\r\ncircle.js in the same directory.\r\n\r\n\r\nThe contents of foo.js:\r\n\r\n\r\nvar circle = require('./circle.js');\r\nconsole.log( 'The area of a circle of radius 4 is '\r\n           + circle.area(4));The contents of circle.js:\r\n\r\n\r\nvar PI = Math.PI;\r\n\r\nexports.area = function (r) {\r\n  return PI * r * r;\r\n};\r\n\r\nexports.circumference = function (r) {\r\n  return 2 * PI * r;\r\n};The module circle.js has exported the functions area() and\r\ncircumference().  To export an object, add to the special exports\r\nobject.\r\n\r\n\r\nNote that exports is a reference to module.exports making it suitable\r\nfor augmentation only. If you are exporting a single item such as a\r\nconstructor you will want to use module.exports directly instead.\r\n\r\n\r\nfunction MyConstructor (opts) {\r\n  //...\r\n}\r\n\r\n// BROKEN: Does not modify exports\r\nexports = MyConstructor;\r\n\r\n// exports the constructor properly\r\nmodule.exports = MyConstructor;Variables\r\nlocal to the module will be private. In this example the variable PI is\r\nprivate to circle.js.\r\n\r\n\r\nThe module system is implemented in the require(\"module\") module." },
            {"addons", "Addons are dynamically linked shared objects. They can provide glue to C and\r\nC++ libraries. The API (at the moment) is rather complex, involving\r\nknowledge of several libraries:\r\n\r\n\r\n* V8 JavaScript, a C++ library. Used for interfacing with JavaScript:\r\ncreating objects, calling functions, etc.  Documented mostly in the\r\nv8.h header file (deps/v8/include/v8.h in the Node source\r\ntree), which is also available\r\nonline.\r\n\r\n* libuv, C event loop library.\r\nAnytime one needs to wait for a file descriptor to become readable,\r\nwait for a timer, or wait for a signal to be received one will need\r\nto interface with libuv. That is, if you perform any I/O, libuv will\r\nneed to be used.\r\n\r\n* Internal Node libraries. Most importantly is the node::ObjectWrap\r\nclass which you will likely want to derive from.\r\n\r\n* Others. Look in deps/ for what else is available.\r\n\r\nNode statically compiles all its dependencies into the executable.\r\nWhen compiling your module, you don't need to worry about linking to\r\nany of these libraries.\r\n\r\n\r\nAll of the following examples are available for\r\ndownload and may be\r\nused as a starting-point for your own Addon." },
            {"util", "These functions are in the module 'util'. Use require('util') to access\r\nthem." },
            {"events", "Many objects in Node emit events: a net.Server emits an event each time\r\na peer connects to it, a fs.readStream emits an event when the file is\r\nopened. All objects which emit events are instances of events.EventEmitter.\r\nYou can access this module by doing: require(\"events\");\r\nTypically, event names are represented by a camel-cased string, however,\r\nthere aren't any strict restrictions on that, as any string will be accepted.\r\n\r\n\r\nFunctions can then be attached to objects, to be executed when an event\r\nis emitted. These functions are called listeners. Inside a listener\r\nfunction, this refers to the EventEmitter that the listener was\r\nattached to." },
            {"domain", "Domains provide a way to handle multiple different IO operations as a\r\nsingle group.  If any of the event emitters or callbacks registered to a\r\ndomain emit an error event, or throw an error, then the domain object\r\nwill be notified, rather than losing the context of the error in the\r\nprocess.on('uncaughtException') handler, or causing the program to\r\nexit immediately with an error code." },
            {"buffer", "Pure JavaScript is Unicode friendly but not nice to binary data.  When\r\ndealing with TCP streams or the file system, it's necessary to handle octet\r\nstreams. Node has several strategies for manipulating, creating, and\r\nconsuming octet streams.\r\n\r\n\r\nRaw data is stored in instances of the Buffer class. A Buffer is similar\r\nto an array of integers but corresponds to a raw memory allocation outside\r\nthe V8 heap. A Buffer cannot be resized.\r\n\r\n\r\nThe Buffer class is a global, making it very rare that one would need\r\nto ever require('buffer').\r\n\r\n\r\nConverting between Buffers and JavaScript string objects requires an explicit\r\nencoding method.  Here are the different string encodings.\r\n\r\n\r\n* 'ascii' - for 7 bit ASCII data only.  This encoding method is very fast, and\r\nwill strip the high bit if set.\r\nNote that when converting from string to buffer, this encoding converts a null\r\ncharacter ('\\0' or '\\u0000') into 0x20 (character code of a space). If\r\nyou want to convert a null character into 0x00, you should use 'utf8'.\r\n\r\n* 'utf8' - Multibyte encoded Unicode characters. Many web pages and other\r\ndocument formats use UTF-8.\r\n\r\n* 'utf16le' - 2 or 4 bytes, little endian encoded Unicode characters.\r\nSurrogate pairs (U+10000 to U+10FFFF) are supported.\r\n\r\n* 'ucs2' - Alias of 'utf16le'.\r\n\r\n* 'base64' - Base64 string encoding.\r\n\r\n* 'binary' - A way of encoding raw binary data into strings by using only\r\nthe first 8 bits of each character. This encoding method is deprecated and\r\nshould be avoided in favor of Buffer objects where possible. This encoding\r\nwill be removed in future versions of Node.\r\n\r\n* 'hex' - Encode each byte as two hexadecimal characters.\r\n\r\nA Buffer object can also be used with typed arrays.  The buffer object is\r\ncloned to an ArrayBuffer that is used as the backing store for the typed\r\narray.  The memory of the buffer and the ArrayBuffer is not shared.\r\n\r\n\r\nNOTE: Node.js v0.8 simply retained a reference to the buffer in array.buffer\r\ninstead of cloning it.\r\n\r\n\r\nWhile more efficient, it introduces subtle incompatibilities with the typed\r\narrays specification.  ArrayBuffer#slice() makes a copy of the slice while\r\nBuffer#slice() creates a view." },
            {"stream", "A stream is an abstract interface implemented by various objects in\r\nNode.  For example a request to an HTTP\r\nserver is a stream, as is\r\n[stdout][]. Streams are readable, writable, or both. All streams are\r\ninstances of [EventEmitter][]\r\n\r\n\r\nYou can load the Stream base classes by doing require('stream').\r\nThere are base classes provided for [Readable][] streams, [Writable][]\r\nstreams, [Duplex][] streams, and [Transform][] streams.\r\n\r\n\r\nThis document is split up into 3 sections.  The first explains the\r\nparts of the API that you need to be aware of to use streams in your\r\nprograms.  If you never implement a streaming API yourself, you can\r\nstop there.\r\n\r\n\r\nThe second section explains the parts of the API that you need to use\r\nif you implement your own custom streams yourself.  The API is\r\ndesigned to make this easy for you to do.\r\n\r\n\r\nThe third section goes into more depth about how streams work,\r\nincluding some of the internal mechanisms and functions that you\r\nshould probably not modify unless you definitely know what you are\r\ndoing." },
            {"crypto", "Stability: 2 - Unstable; API changes are being discussed for\r\nfuture versions.  Breaking changes will be minimized.  See below.Use require('crypto') to access this module.\r\n\r\n\r\nThe crypto module offers a way of encapsulating secure credentials to be\r\nused as part of a secure HTTPS net or http connection.\r\n\r\n\r\nIt also offers a set of wrappers for OpenSSL's hash, hmac, cipher,\r\ndecipher, sign and verify methods." },
            {"tls", "Use require('tls') to access this module.\r\n\r\n\r\nThe tls module uses OpenSSL to provide Transport Layer Security and/or\r\nSecure Socket Layer: encrypted stream communication.\r\n\r\n\r\nTLS/SSL is a public/private key infrastructure. Each client and each\r\nserver must have a private key. A private key is created like this\r\n\r\n\r\nopenssl genrsa -out ryans-key.pem 1024All severs and some clients need to have a certificate. Certificates are public\r\nkeys signed by a Certificate Authority or self-signed. The first step to\r\ngetting a certificate is to create a \"Certificate Signing Request\" (CSR)\r\nfile. This is done with:\r\n\r\n\r\nopenssl req -new -key ryans-key.pem -out ryans-csr.pemTo create a self-signed certificate with the CSR, do this:\r\n\r\n\r\nopenssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pemAlternatively you can send the CSR to a Certificate Authority for signing.\r\n\r\n\r\n(TODO: docs on creating a CA, for now interested users should just look at\r\ntest/fixtures/keys/Makefile in the Node source code)\r\n\r\n\r\nTo create .pfx or .p12, do this:\r\n\r\n\r\nopenssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \\\r\n    -certfile ca-cert.pem -out agent5.pfx* in:  certificate\r\n* inkey: private key\r\n* certfile: all CA certs concatenated in one file like\r\ncat ca1-cert.pem ca2-cert.pem > ca-cert.pem" },
            {"stringdecoder", "To use this module, do require('string_decoder'). StringDecoder decodes a\r\nbuffer to a string. It is a simple interface to buffer.toString() but provides\r\nadditional support for utf8.\r\n\r\n\r\nvar StringDecoder = require('string_decoder').StringDecoder;\r\nvar decoder = new StringDecoder('utf8');\r\n\r\nvar cent = new Buffer([0xC2, 0xA2]);\r\nconsole.log(decoder.write(cent));\r\n\r\nvar euro = new Buffer([0xE2, 0x82, 0xAC]);\r\nconsole.log(decoder.write(euro));" },
            {"fs", "File I/O is provided by simple wrappers around standard POSIX functions.  To\r\nuse this module do require('fs'). All the methods have asynchronous and\r\nsynchronous forms.\r\n\r\n\r\nThe asynchronous form always take a completion callback as its last argument.\r\nThe arguments passed to the completion callback depend on the method, but the\r\nfirst argument is always reserved for an exception. If the operation was\r\ncompleted successfully, then the first argument will be null or undefined.\r\n\r\n\r\nWhen using the synchronous form any exceptions are immediately thrown.\r\nYou can use try/catch to handle exceptions or allow them to bubble up.\r\n\r\n\r\nHere is an example of the asynchronous version:\r\n\r\n\r\nvar fs = require('fs');\r\n\r\nfs.unlink('/tmp/hello', function (err) {\r\n  if (err) throw err;\r\n  console.log('successfully deleted /tmp/hello');\r\n});Here is the synchronous version:\r\n\r\n\r\nvar fs = require('fs');\r\n\r\nfs.unlinkSync('/tmp/hello')\r\nconsole.log('successfully deleted /tmp/hello');With the asynchronous methods there is no guaranteed ordering. So the\r\nfollowing is prone to error:\r\n\r\n\r\nfs.rename('/tmp/hello', '/tmp/world', function (err) {\r\n  if (err) throw err;\r\n  console.log('renamed complete');\r\n});\r\nfs.stat('/tmp/world', function (err, stats) {\r\n  if (err) throw err;\r\n  console.log('stats: ' + JSON.stringify(stats));\r\n});It could be that fs.stat is executed before fs.rename.\r\nThe correct way to do this is to chain the callbacks.\r\n\r\n\r\nfs.rename('/tmp/hello', '/tmp/world', function (err) {\r\n  if (err) throw err;\r\n  fs.stat('/tmp/world', function (err, stats) {\r\n    if (err) throw err;\r\n    console.log('stats: ' + JSON.stringify(stats));\r\n  });\r\n});In busy processes, the programmer is strongly encouraged to use the\r\nasynchronous versions of these calls. The synchronous versions will block\r\nthe entire process until they complete--halting all connections.\r\n\r\n\r\nRelative path to filename can be used, remember however that this path will be\r\nrelative to process.cwd().\r\n\r\n\r\nMost fs functions let you omit the callback argument. If you do, a default\r\ncallback is used that ignores errors, but prints a deprecation\r\nwarning.\r\n\r\n\r\nIMPORTANT: Omitting the callback is deprecated.  v0.12 will throw the\r\nerrors as exceptions." },
            {"path", "This module contains utilities for handling and transforming file\r\npaths.  Almost all these methods perform only string transformations.\r\nThe file system is not consulted to check whether paths are valid.\r\n\r\n\r\nUse require('path') to use this module.  The following methods are provided:" },
            {"net", "The net module provides you with an asynchronous network wrapper. It contains\r\nmethods for creating both servers and clients (called streams). You can include\r\nthis module with require('net');" },
            {"dgram", "Datagram sockets are available through require('dgram').\r\n\r\n\r\nImportant note: the behavior of dgram.Socket#bind() has changed in v0.10\r\nand is always asynchronous now.  If you have code that looks like this:\r\n\r\n\r\nvar s = dgram.createSocket('udp4');\r\ns.bind(1234);\r\ns.addMembership('224.0.0.114');You have to change it to this:\r\n\r\n\r\nvar s = dgram.createSocket('udp4');\r\ns.bind(1234, function() {\r\n  s.addMembership('224.0.0.114');\r\n});" },
            {"dns", "Use require('dns') to access this module. All methods in the dns module\r\nuse C-Ares except for dns.lookup which uses getaddrinfo(3) in a thread\r\npool. C-Ares is much faster than getaddrinfo but the system resolver is\r\nmore constant with how other programs operate. When a user does\r\nnet.connect(80, 'google.com') or http.get({ host: 'google.com' }) the\r\ndns.lookup method is used. Users who need to do a large number of lookups\r\nquickly should use the methods that go through C-Ares.\r\n\r\n\r\nHere is an example which resolves 'www.google.com' then reverse\r\nresolves the IP addresses which are returned.\r\n\r\n\r\nvar dns = require('dns');\r\n\r\ndns.resolve4('www.google.com', function (err, addresses) {\r\n  if (err) throw err;\r\n\r\n  console.log('addresses: ' + JSON.stringify(addresses));\r\n\r\n  addresses.forEach(function (a) {\r\n    dns.reverse(a, function (err, domains) {\r\n      if (err) {\r\n        throw err;\r\n      }\r\n\r\n      console.log('reverse for ' + a + ': ' + JSON.stringify(domains));\r\n    });\r\n  });\r\n});" },
            {"http", "To use the HTTP server and client one must require('http').\r\n\r\n\r\nThe HTTP interfaces in Node are designed to support many features\r\nof the protocol which have been traditionally difficult to use.\r\nIn particular, large, possibly chunk-encoded, messages. The interface is\r\ncareful to never buffer entire requests or responses--the\r\nuser is able to stream data.\r\n\r\n\r\nHTTP message headers are represented by an object like this:\r\n\r\n\r\n{ 'content-length': '123',\r\n  'content-type': 'text/plain',\r\n  'connection': 'keep-alive',\r\n  'accept': '*/*' }Keys are lowercased. Values are not modified.\r\n\r\n\r\nIn order to support the full spectrum of possible HTTP applications, Node's\r\nHTTP API is very low-level. It deals with stream handling and message\r\nparsing only. It parses a message into headers and body but it does not\r\nparse the actual headers or the body." },
            {"https", "HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a\r\nseparate module." },
            {"url", "This module has utilities for URL resolution and parsing.\r\nCall require('url') to use it.\r\n\r\n\r\nParsed URL objects have some or all of the following fields, depending on\r\nwhether or not they exist in the URL string. Any parts that are not in the URL\r\nstring will not be in the parsed object. Examples are shown for the URL\r\n\r\n\r\n'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'\r\n* href: The full URL that was originally parsed. Both the protocol and host are lowercased.\r\n  Example: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'\r\n\r\n* protocol: The request protocol, lowercased.\r\n  Example: 'http:'\r\n\r\n* host: The full lowercased host portion of the URL, including port\r\ninformation.\r\n  Example: 'host.com:8080'\r\n\r\n* auth: The authentication information portion of a URL.\r\n  Example: 'user:pass'\r\n\r\n* hostname: Just the lowercased hostname portion of the host.\r\n  Example: 'host.com'\r\n\r\n* port: The port number portion of the host.\r\n  Example: '8080'\r\n\r\n* pathname: The path section of the URL, that comes after the host and\r\nbefore the query, including the initial slash if present.\r\n  Example: '/p/a/t/h'\r\n\r\n* search: The 'query string' portion of the URL, including the leading\r\nquestion mark.\r\n  Example: '?query=string'\r\n\r\n* path: Concatenation of pathname and search.\r\n  Example: '/p/a/t/h?query=string'\r\n\r\n* query: Either the 'params' portion of the query string, or a\r\nquerystring-parsed object.\r\n  Example: 'query=string' or {'query':'string'}\r\n\r\n* hash: The 'fragment' portion of the URL including the pound-sign.\r\n  Example: '#hash'\r\n\r\nThe following methods are provided by the URL module:" },
            {"querystring", "This module provides utilities for dealing with query strings.\r\nIt provides the following methods:" },
            {"punycode", "Punycode.js is bundled with Node.js v0.6.2+. Use\r\nrequire('punycode') to access it. (To use it with other Node.js versions,\r\nuse npm to install the punycode module first.)" },
            {"readline", "To use this module, do require('readline'). Readline allows reading of a\r\nstream (such as process.stdin) on a line-by-line basis.\r\n\r\n\r\nNote that once you've invoked this module, your node program will not\r\nterminate until you've closed the interface. Here's how to allow your\r\nprogram to gracefully exit:\r\n\r\n\r\nvar readline = require('readline');\r\n\r\nvar rl = readline.createInterface({\r\n  input: process.stdin,\r\n  output: process.stdout\r\n});\r\n\r\nrl.question(\"What do you think of node.js? \", function(answer) {\r\n  // TODO: Log the answer in a database\r\n  console.log(\"Thank you for your valuable feedback:\", answer);\r\n\r\n  rl.close();\r\n});" },
            {"repl", "A Read-Eval-Print-Loop (REPL) is available both as a standalone program and\r\neasily includable in other programs. The REPL provides a way to interactively\r\nrun JavaScript and see the results.  It can be used for debugging, testing, or\r\njust trying things out.\r\n\r\n\r\nBy executing node without any arguments from the command-line you will be\r\ndropped into the REPL. It has simplistic emacs line-editing.\r\n\r\n\r\nmjr:~$ node\r\nType '.help' for options.\r\n> a = [ 1, 2, 3];\r\n[ 1, 2, 3 ]\r\n> a.forEach(function (v) {\r\n...   console.log(v);\r\n...   });\r\n1\r\n2\r\n3For advanced line-editors, start node with the environmental variable\r\nNODE_NO_READLINE=1. This will start the main and debugger REPL in canonical\r\nterminal settings which will allow you to use with rlwrap.\r\n\r\n\r\nFor example, you could add this to your bashrc file:\r\n\r\n\r\nalias node=\"env NODE_NO_READLINE=1 rlwrap node\"" },
            {"vm", "You can access this module with:\r\n\r\n\r\nvar vm = require('vm');JavaScript code can be compiled and run immediately or compiled, saved, and run later." },
            {"child_process", "Node provides a tri-directional popen(3) facility through the\r\nchild_process module.\r\n\r\n\r\nIt is possible to stream data through a child's stdin, stdout, and\r\nstderr in a fully non-blocking way.  (Note that some programs use\r\nline-buffered I/O internally.  That doesn't affect node.js but it means\r\ndata you send to the child process is not immediately consumed.)\r\n\r\n\r\nTo create a child process use require('child_process').spawn() or\r\nrequire('child_process').fork().  The semantics of each are slightly\r\ndifferent, and explained below." },
            {"assert", "This module is used for writing unit tests for your applications, you can\r\naccess it with require('assert')." },
            {"tty", "The tty module houses the tty.ReadStream and tty.WriteStream classes. In\r\nmost cases, you will not need to use this module directly.\r\n\r\n\r\nWhen node detects that it is being run inside a TTY context, then process.stdin\r\nwill be a tty.ReadStream instance and process.stdout will be\r\na tty.WriteStream instance. The preferred way to check if node is being run in\r\na TTY context is to check process.stdout.isTTY:\r\n\r\n\r\n$ node -p -e \"Boolean(process.stdout.isTTY)\"\r\ntrue\r\n$ node -p -e \"Boolean(process.stdout.isTTY)\" | cat\r\nfalse" },
            {"zlib", "You can access this module with:\r\n\r\n\r\nvar zlib = require('zlib');This provides bindings to Gzip/Gunzip, Deflate/Inflate, and\r\nDeflateRaw/InflateRaw classes.  Each class takes the same options, and\r\nis a readable/writable Stream.\r\n\r\n\r\nExamples\r\nCompressing or decompressing a file can be done by piping an\r\nfs.ReadStream into a zlib stream, then into an fs.WriteStream.\r\n\r\n\r\nvar gzip = zlib.createGzip();\r\nvar fs = require('fs');\r\nvar inp = fs.createReadStream('input.txt');\r\nvar out = fs.createWriteStream('input.txt.gz');\r\n\r\ninp.pipe(gzip).pipe(out);Compressing or decompressing data in one step can be done by using\r\nthe convenience methods.\r\n\r\n\r\nvar input = '.................................';\r\nzlib.deflate(input, function(err, buffer) {\r\n  if (!err) {\r\n    console.log(buffer.toString('base64'));\r\n  }\r\n});\r\n\r\nvar buffer = new Buffer('eJzT0yMAAGTvBe8=', 'base64');\r\nzlib.unzip(buffer, function(err, buffer) {\r\n  if (!err) {\r\n    console.log(buffer.toString());\r\n  }\r\n});To use this module in an HTTP client or server, use the\r\naccept-encoding\r\non requests, and the\r\ncontent-encoding\r\nheader on responses.\r\n\r\n\r\nNote: these examples are drastically simplified to show\r\nthe basic concept.  Zlib encoding can be expensive, and the results\r\nought to be cached.  See Memory Usage Tuning\r\nbelow for more information on the speed/memory/compression\r\ntradeoffs involved in zlib usage.\r\n\r\n\r\n// client request example\r\nvar zlib = require('zlib');\r\nvar http = require('http');\r\nvar fs = require('fs');\r\nvar request = http.get({ host: 'izs.me',\r\n                         path: '/',\r\n                         port: 80,\r\n                         headers: { 'accept-encoding': 'gzip,deflate' } });\r\nrequest.on('response', function(response) {\r\n  var output = fs.createWriteStream('izs.me_index.html');\r\n\r\n  switch (response.headers['content-encoding']) {\r\n    // or, just use zlib.createUnzip() to handle both cases\r\n    case 'gzip':\r\n      response.pipe(zlib.createGunzip()).pipe(output);\r\n      break;\r\n    case 'deflate':\r\n      response.pipe(zlib.createInflate()).pipe(output);\r\n      break;\r\n    default:\r\n      response.pipe(output);\r\n      break;\r\n  }\r\n});\r\n\r\n// server example\r\n// Running a gzip operation on every request is quite expensive.\r\n// It would be much more efficient to cache the compressed buffer.\r\nvar zlib = require('zlib');\r\nvar http = require('http');\r\nvar fs = require('fs');\r\nhttp.createServer(function(request, response) {\r\n  var raw = fs.createReadStream('index.html');\r\n  var acceptEncoding = request.headers['accept-encoding'];\r\n  if (!acceptEncoding) {\r\n    acceptEncoding = '';\r\n  }\r\n\r\n  // Note: this is not a conformant accept-encoding parser.\r\n  // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3\r\n  if (acceptEncoding.match(/\\bdeflate\\b/)) {\r\n    response.writeHead(200, { 'content-encoding': 'deflate' });\r\n    raw.pipe(zlib.createDeflate()).pipe(response);\r\n  } else if (acceptEncoding.match(/\\bgzip\\b/)) {\r\n    response.writeHead(200, { 'content-encoding': 'gzip' });\r\n    raw.pipe(zlib.createGzip()).pipe(response);\r\n  } else {\r\n    response.writeHead(200, {});\r\n    raw.pipe(response);\r\n  }\r\n}).listen(1337);" },
            {"os", "Provides a few basic operating-system related utility functions.\r\n\r\n\r\nUse require('os') to access this module." },
            {"cluster", "A single instance of Node runs in a single thread. To take advantage of\r\nmulti-core systems the user will sometimes want to launch a cluster of Node\r\nprocesses to handle the load.\r\n\r\n\r\nThe cluster module allows you to easily create a network of processes that\r\nall share server ports.\r\n\r\n\r\nvar cluster = require('cluster');\r\nvar http = require('http');\r\nvar numCPUs = require('os').cpus().length;\r\n\r\nif (cluster.isMaster) {\r\n  // Fork workers.\r\n  for (var i = 0; i < numCPUs; i++) {\r\n    cluster.fork();\r\n  }\r\n\r\n  cluster.on('exit', function(worker, code, signal) {\r\n    console.log('worker ' + worker.process.pid + ' died');\r\n  });\r\n} else {\r\n  // Workers can share any TCP connection\r\n  // In this case its a HTTP server\r\n  http.createServer(function(req, res) {\r\n    res.writeHead(200);\r\n    res.end(\"hello world\\n\");\r\n  }).listen(8000);\r\n}Running node will now share port 8000 between the workers:\r\n\r\n\r\n% NODE_DEBUG=cluster node server.js\r\n23521,Master Worker 23524 online\r\n23521,Master Worker 23526 online\r\n23521,Master Worker 23523 online\r\n23521,Master Worker 23528 onlineThis feature was introduced recently, and may change in future versions.\r\nPlease try it out and provide feedback.\r\n\r\n\r\nAlso note that, on Windows, it is not yet possible to set up a named pipe\r\nserver in a worker." },
        };
    }
}
